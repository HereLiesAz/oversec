package io.oversec.one.crypto.ui

import android.app.Activity
import android.app.ActivityOptions
import android.content.Context
import android.content.Intent
import android.content.IntentSender
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.FrameLayout
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.viewinterop.AndroidView
import androidx.fragment.app.FragmentContainerView
import io.oversec.one.common.CoreContract
import io.oversec.one.crypto.*
//import kotlinx.android.synthetic.main.activity_encryption_info.*
import roboguice.util.Ln

class EncryptionInfoActivity : AppCompatActivity() {
    private var mTdr: BaseDecryptResult? = null
    private var mOrigText: String? = null

    private lateinit var mFragment: AbstractTextEncryptionInfoFragment
    private lateinit var mEncryptionHandler: AbstractCryptoHandler

    @OptIn(ExperimentalMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        //make sure to clear any pending decrypt tasks in the background, as they might interfere with pending intents generated by the user in the UI thread of this activity
        CryptoHandlerFacade.getInstance(this).clearDecryptQueue()

        mOrigText = intent.getStringExtra(EXTRA_ENCRYPTED_TEXT)
        val mPackageName = intent.getStringExtra(EXTRA_PACKAGENAME)

        val aEncryptionHandler = CryptoHandlerFacade.getInstance(this).getCryptoHandler(mOrigText!!)
        if (aEncryptionHandler == null) {
            finish()
            return
        }

        aEncryptionHandler.let {
            mEncryptionHandler = it;
            mFragment = it.getTextEncryptionInfoFragment(mPackageName)
        }
        mFragment.setArgs(mPackageName)

        setContent {
            MaterialTheme {
                EncryptionInfoScreen(
                    fragment = mFragment,
                    onNavigateUp = {
                        finish()
                        setupExitTransition()
                    }
                )
            }
        }
    }

    override fun onResumeFragments() {
        update(null)
        super.onResumeFragments()
    }

    fun update(actionIntent: Intent?) {
        if (actionIntent == null && mTdr != null) {
            return
        }

        var uix: UserInteractionRequiredException? = null
        try {
            mTdr = CryptoHandlerFacade.getInstance(this).decryptWithLock(mOrigText!!, actionIntent)
        } catch (e: UserInteractionRequiredException) {
            val atdr = CoreContract.instance!!.getFromEncryptionCache(mOrigText!!)
            if (atdr != null) {
                mTdr = atdr
            } else {
                uix = e
            }
        }
        mFragment.setData(this, mOrigText!!, mTdr, uix, mEncryptionHandler)
    }

    fun update(decryptResult: BaseDecryptResult) {
        mTdr = decryptResult
        mFragment.setData(this, mOrigText!!, decryptResult, null, mEncryptionHandler)
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // This will now be handled by the fragment inside the Compose layout
        return super.onCreateOptionsMenu(menu)
    }

    override fun onPrepareOptionsMenu(menu: Menu): Boolean {
        // This will now be handled by the fragment inside the Compose layout
        return super.onPrepareOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        // The navigation is handled by the TopAppBar, the rest is delegated.
        if (mFragment.onOptionsItemSelected(this, item)) {
            return true
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onBackPressed() {
        super.onBackPressed()
        setupExitTransition()
    }

    private fun setupExitTransition() {
        overridePendingTransition(0, R.anim.activity_out)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode) // Let fragment handle it
        if (requestCode == REQUEST_CODE_DECRYPT) {
            if (resultCode == Activity.RESULT_OK) {
                val nodeOrigText = intent.getStringExtra(EXTRA_ENCRYPTED_TEXT)
                try {
                    val dr = CryptoHandlerFacade.getInstance(this).decryptWithLock(nodeOrigText, data)
                    CoreContract.instance!!.putInEncryptionCache(nodeOrigText, dr!!)
                    update(dr)
                } catch (e: UserInteractionRequiredException) {
                    try {
                        startIntentSenderForResult(e.pendingIntent.intentSender, REQUEST_CODE_DECRYPT, null, 0, 0, 0)
                    } catch (e1: IntentSender.SendIntentException) {
                        // and now??
                    }
                }
            } else {
                Ln.w("user cancelled pendingintent activity")
            }
        } else if (requestCode == REQUEST_CODE_DOWNLOAD_MISSING_KEYS) {
            if (resultCode == Activity.RESULT_OK) {
                update(data)
            } else {
                Ln.w("user cancelled pendingintent activity")
            }
        } else if (requestCode == REQUEST_CODE_SHOW_SIGNATURE_KEY) {
            //nothing to be done
        }
    }

    companion object {
        private const val EXTRA_ENCRYPTED_TEXT = "enc_text"
        private const val EXTRA_PACKAGENAME = "packagename"
        const val REQUEST_CODE_DECRYPT = 5001
        const val REQUEST_CODE_DOWNLOAD_MISSING_KEYS = 5002
        const val REQUEST_CODE_SHOW_SIGNATURE_KEY = 5003
        fun show(ctx: Context, packagename: String, encryptedText: String, source: View?) {
            val i = Intent(ctx, EncryptionInfoActivity::class.java)
            i.putExtra(EXTRA_ENCRYPTED_TEXT, encryptedText)
            i.putExtra(EXTRA_PACKAGENAME, packagename)
            i.flags = (Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
            val opts = source?.let { ActivityOptions.makeScaleUpAnimation(it, 0, 0, 0, 0) }
            if (opts != null) {
                ctx.startActivity(i, opts.toBundle())
            } else {
                ctx.startActivity(i)
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EncryptionInfoScreen(
    fragment: AbstractTextEncryptionInfoFragment,
    onNavigateUp: () -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { /* The fragment will set the title */ },
                navigationIcon = {
                    IconButton(onClick = onNavigateUp) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        FragmentContainer(
            modifier = Modifier.padding(paddingValues),
            fragment = fragment
        )
    }
}

@Composable
fun FragmentContainer(
    modifier: Modifier = Modifier,
    fragment: AbstractTextEncryptionInfoFragment
) {
    val containerId = remember { View.generateViewId() }
    AndroidView(
        modifier = modifier,
        factory = { context ->
            FragmentContainerView(context).apply {
                id = containerId
            }
        },
        update = { view ->
            val fragmentManager = (view.context as AppCompatActivity).fragmentManager
            val currentFragment = fragmentManager.findFragmentById(view.id)
            if (currentFragment?.javaClass != fragment.javaClass) {
                fragmentManager.beginTransaction()
                    .replace(view.id, fragment)
                    .commit()
            }
        }
    )
}
